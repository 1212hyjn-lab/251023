📕관리 : crud

- create : postmapping       -> save, save all
- read : getmapping          -> findbyid, findall
- update : putmapping       -> update
- delete : deletemapping     -> delete

저장목적 맵핑에는 동사형을 쓰지 않는다, save all도 마찬가지
update에서는 /{id}로
=해당부분 메모장 참고

gui/ cli (깃) = i : interface

serviceimpl 에서의 class 와 service에서는 interface
- interface란// 비교대상이 class가 있다
  공통점은 타입이다, 도커에서는 이미지가 된다.
  pull(import)을 하면 타입과 인스턴스가 같이 생성된다
  엄연히 타입은 본래 클래스명이다.
- 클래스 인스턴스 = 뉴 :: 만으로 잡지 않고
  interfacef로도 잡을 수 있다
- 즉 타입은 클래스와 인터페이스로 정의를 내릴 수 있다.

그렇다면 두가지의 차이점은 뭘까
클래스의 타입과 인터페이스 타입의 차이점을 보려고 한다.
<<한가지더, 이미지도 타입이 될 수 있다>>// postgre에서도 타입은 존재한다

1. html에서의 속성은  attribute로 되어있다 (property가 아님)
2. 다른 것과 마찬가지로 
3. varchar = string임 / variable + char이다



📕도커에서 이미지는 타입인데,, 타입은 어디에 쓰는가?

- 헤라클레이토스/ 파르메니데스 = 모든 것은 변한다/ 불변
헤라클레이토스는 약간 오늘만 살자면
소크라테스는 불변의 진리를 말함 (constant)

- 형이상학(위)과 형이하학/ 위를 가르키는 것은 메타(타입), 아래를 인스턴스?
플라톤을 타입으로 비유하셨는데 약간 허상을 쫓음. 허상이 있어야 실제도 있고 그러므로 정의가 된다고 생각하는 사람.
형태를 구분지으려고 하는데 사실 타입은 형상이 없음(예 - 하이미디어를 그림으로 그리시오 하면 그릴 수 없음. 그러나 하이미디어라는 것이 존재는 하므로 인지는 할 수 있음// 이것을 우린 추상이라고 부름)
남성과 여성도 그림으로 나타내기 애매하니 우리는 기호를 써서 위아래로 나눈다.
그의 제자는 허상이 아닌 실제를 중요시함.
여기서 형은 타입이다.
엑셀에서 스키마 윗부분이 타입이다
나이가 중요하지 숫자가 중요한 것은 아니다

- 이미지라고 부르는 도커에서의 타입은 그 이미지가 아님 허상임
  컨테이너는 이미지라는 것이 감싸고 있는데 실제로 파워셀에서 컨테이너로 들어가는 것이 터미널에서 보임// 컨테이너는 실존임

📕그러나 디스크에서의 타입은 실존하는 것이 맞다
import는 이미지를 불러옴
우리 자바에서 서비스를 들어가보면 클래스 안에 messenger 부분이 실존하는 것임
사람의 이름은 지칭대상이지 실존하는 것이 아니다.
클래스명도 이름이니 지칭을 하는 것일뿐 안에 있는 것이 실제 땅이고 점유지이다.

이름이 없으면 사람은 존재하지 않는다.
우리나라는 태아때부터 존재를 받지만 서양은 사람이 땅을 밟아야 존재한다고 생각
메서드는 기능을 존재하는 것인데 기능이 비어있기 때문에 빈땅으로 본다.
땅이 존재해서 밟을 순 있으나 빌딩이 없다(컨테이너가 없다)

p.78 컨테이너와 이미지 같이 있는 사진

Messenger save(ProductDTO product)
의자는 땅 (이미지)/ 전 지구에서 좌표로 그 자리를 찍을 수 있음(불변)
그 위에 사람이 서 있으면 객체가 된다// 사람이 땅위에 서면 주소확정임
사람이 서지 않으면 주소는 없어
근데 터를 잡고 사람이 돌아다니면 본진은 있음, 실은 원본은 거기에 있고 카피본이 돌아다니면서 심부름을 하는 것임 (인스턴스)

즉 Messenger은 존재하는 것이 아님 저긴 이미지 자리잖아
save의 뒤는 메소드이다. 메소드의 타입이 돼
메소드가 비었다고 한게 중괄호가 없어서

현재 지금 우리는 메모리로 생각해야해서 타입 안에 있는 것은 실존하는 것이 아니라고 생각해여해  ---->????? 댕소리


📕도커는 가상메모리임// 깃은 메모리임, 클라우드도 메모리
도커는 모든 것을 다 가상으로 만든다
가상의 세계를 여는 것이 타입과 주소(메모리도, 가상 디스크도 가능) 형태로 만들어야 열림..
이렇게 주소를 만들면 해당 땅에 빌딩의 종류가 생성이 되는 것
건물의 종류는 타입이 결정짓는데 주소에 아파트가 생겨도 주소로 부르지 않고
압구정 현대 같은 명칭을 사용하게 된다. _개념_


객체타입과 인터페이스 타입은 각각 속성 또는 기능만 가지고 있다.
테이블은 타입이 스키마다. (스키마 긁어서 디비 만들었잖아)

기능 선언 = 인터페이스(임플먼트)와 타입
속성 선언 = 익스텐드 오브젝트                 // 그니까 항상 두개가 같이 있어"가 포인트

📕테이블의 부모는 디비다
테이블을 만들고 싶으면 우리는 디비를 만들어야 한다
우리가 서비스에서 보면 클래스 안에 메서드가 있는데 비어있고
서비스 임플먼트 안에 그 형체가 들어가 있게 된다.
임플먼트가 오면 타입과 알맹이가 뒤바뀐다.

마찬가지로 우리가 도커에서 테이블을 만들려면 디비가 있어야 하는데
이때 디비가 부모가 된다. 메서드가 비었는데 다른 공간에서 몸뚱이가 있듯이
마찬가지다.

서양은 속성과 기능을 자꾸 분리시킨다_ 그들의 문화다_

타입이 없으면 어딘가에 있다고 생각하면 된다,, 없을 순 없어

private String xxx; -> xxx = 스키마(하나하나를 property , 속성집합 스키마). 
컬럼의 집합도 스키마


📕CREATE TABLE에서는 ()사용 {}은 사용을 하지 않는다
이유는 = 그냥 서로 언어가 다른 것임
sql에서는 ()={}

private String xxx; = colume database;  (자바 = 도커)
속성이 같으면 동일체, 이름이 같을 필요가 없어
순서와 갯수가 같아야함

a-b = a_b // userId + user_id
자바에서 스키마 한줄을 userDTO에 넣어 그것을 도커에서는 갯수가 많아져
즉 갯수를 맞춰주는게 스키마에 다양한 디비값이 잇어서 한줄이지만 그 줄에
다수의 갯수가 들어가서 그것을 맞춤

컨트롤러에 requestmapping 괄호에는 테이블 네임이 들어가는 것
종착역 테이블로 연결된 길


✔실습시작
윈도우는 c언어
sysdm.cpl ,3       /// 
appwiz.cpl         /// 웹마법사


📕cli가 되어야 gui가 되는 것

🧨테이블 생성하기 전에 디비를 만들어야 하는데 디비를 만들긴 하였으나
지금은 컨테이너 복사하기 전에 tmp가 없어서 만들지 못하였음

1. docker pull postgres:15
2. docker run -d --name aiion --restart unless-stopped -e POSTGRES_USER=aiion -e POSTGRES_PASSWORD=aiion4man -e POSTGRES_DB=aidb -p 5432:5432 -v pgdata:/var/lib/postgresql/data --health-cmd="pg_isready -U app" --health-interval=10s --health-timeout=5s --health-retries=5 postgres:15
3. docker ps
4. docker exec -it aiion bash
5. psql -U aiion -d aidb
6. ALTER USER aiion WITH PASSWORD 'aiion4man';  😊생략가능
7. docker cp src/main/resources/static/csv/test.csv aiion:/tmp/test.csv
8. tmp가 여기서 없엇음
docker exec aiion ls -ld /tmp// tmp확인 -> 없음
docker exec aiion mkdir -p /tmp  // 만듬

 9. docker exec aiion psql -U aiion -d aidb -c "CREATE TABLE IF NOT EXISTS test (id SERIAL PRIMARY KEY, date DATE, entry TEXT, summary TEXT, language VARCHAR(50), notes TEXT);"
 10. docker exec aiion psql -U aiion -d aidb -c "COPY test(date, entry, summary, language, notes) FROM '/tmp/test.csv' WITH (FORMAT csv, HEADER true, DELIMITER ',');"
 11. SELECT * FROM test;
터미널에서 전체 확인!

**테이블 삭제- DROP TABLE test;**
이게 이제 테이블 안으로 들어가서 보는거 :: 테이블 구조확인 \d or \dt
디는 단순히 하나만 나옴

-------------------------------------------------------------------

✔pgadmin -> 테이블 안에 넣었던 데이터시트를 보기 위해서
테스트 우클릭 후 뷰 다음 all rows 클릭하면 보인다.

📕터미널로 들어와서 바꾸는 것을 코멘드라고 한다.
erd -> relation : 관계 = 테이블 (종류는 두가지가 있다 ~크로우핏, 1=>일대다)
![[Pasted image 20251028160311.png]]
부모는 왼쪽 | 이것이 되는 것 부모자식관계를 말해

일대일도 있어 => null관계(없어도 돼) :: 일대일은 시블링관계가 있는데
pk를 자식이 가지고 있으면 종속관계임 -> 확인필수🎈

다대다는 물리적으로 존재할 수 없음 = 다대다로 연결할 거면 중간에 테이블 무조건 필

연고지 하나에 팀 하나는 협회에서 정한 룰이야 그래서 일대일로 이루어져 있어
그러나 팀에 소속된 선수들은 종속이니까 부모관계
일정도 경기장에 소속되어있어
그러나, 선수와 일정은 관련이 없다 :: 따라서, 어떠한 관계도 이루어지지 않는다
(x에 참고해서 관계 이미지 확인 할 것)

부모와 자식이 있을 때
자식은 부모의 pk를 갖는다 그래서 자식부분 칸에 fk라고 해서 부모의 상속된 값이 보임

💎쿼리문은 select 값 밖에 받지 못한다 (find, getm)     - read   ::쿼리가 중요
from는 products, users/  where가 id임 / all = *  where에서는 컬럼

코멘드니까 insert가 되는 거야 (쿼리 제외 모두 코멘드 : ) - create, update, delete



